import socket
import ssl
import re
from datetime import datetime

class VulnerabilityScanner:
    def __init__(self, timeout=5):
        self.timeout = timeout
        self.vulnerabilities = []

    def _check_ssl_vulnerabilities(self, target, port=443):
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((target, port), timeout=self.timeout) as sock:
                with context.wrap_socket(sock, server_hostname=target) as ssock:
                    cert = ssock.getpeercert()
                    
                    not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    days_remaining = (not_after - datetime.utcnow()).days
                    
                    if days_remaining < 30:
                        self.vulnerabilities.append({
                            'type': 'ssl_cert_expiry',
                            'severity': 'medium',
                            'details': f'Certificate expires in {days_remaining} days',
                            'port': port,
                            'protocol': 'tcp'
                        })
                    
                    try:
                        for version in [ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_TLSv1, 
                                      ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_TLSv1_2]:
                            try:
                                with socket.create_connection((target, port), timeout=self.timeout) as s:
                                    with ssl.wrap_socket(s, ssl_version=version) as ssock:
                                        if version in [ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv3, 
                                                     ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1_1]:
                                            self.vulnerabilities.append({
                                                'type': 'insecure_protocol',
                                                'severity': 'high',
                                                'details': f'Insecure protocol version: {ssl.get_protocol_name(version)}',
                                                'port': port,
                                                'protocol': 'tcp'
                                            })
                            except (ssl.SSLError, ConnectionRefusedError, socket.timeout):
                                continue
                    except Exception:
                        pass
        except Exception as e:
            pass

    def _check_common_vulnerabilities(self, target, port, banner):
        vuln_checks = [
            {
                'name': 'ftp_anonymous',
                'port': 21,
                'banner_pattern': r'220.*FTP',
                'check': lambda s: s.startswith('220') and 'FTP' in s,
                'severity': 'medium',
                'description': 'Anonymous FTP login allowed'
            },
            {
                'name': 'telnet_enabled',
                'port': 23,
                'banner_pattern': r'^.*telnet.*$',
                'check': lambda s: 'telnet' in s.lower(),
                'severity': 'high',
                'description': 'Telnet service is enabled (insecure)'
            },
            {
                'name': 'http_server_header',
                'port': [80, 443, 8080, 8443],
                'banner_pattern': r'^Server:.*$',
                'check': lambda s: 'Server:' in s,
                'severity': 'info',
                'description': 'Web server version disclosure'
            }
        ]

        for check in vuln_checks:
            if isinstance(check['port'], list):
                if port not in check['port']:
                    continue
            elif port != check['port']:
                continue

            if banner and check.get('check')(banner):
                self.vulnerabilities.append({
                    'type': check['name'],
                    'severity': check['severity'],
                    'details': check['description'],
                    'port': port,
                    'protocol': 'tcp'
                })

    def scan_port(self, target, port, protocol='tcp', banner=None):
        if protocol.lower() == 'tcp' and port == 443:
            self._check_ssl_vulnerabilities(target, port)
        
        if banner:
            self._check_common_vulnerabilities(target, port, banner)
        
        return self.vulnerabilities

    def get_vulnerabilities(self):
        return self.vulnerabilities
